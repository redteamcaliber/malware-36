package preprocess;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

public class Main {
	static Map<String, Boolean> instruc = new HashMap<String, Boolean>();

	public static void main(String[] args) {
		// trimFile("/media/06609F07609EFD1D/train");
		// trimFile("/media/06609F07609EFD1D/test");
		initMap();
		featureExtract("/media/06609F07609EFD1D/train", "/media/06609F07609EFD1D/test", "train.arff");

		// instru();
		// listInstru("/media/06609F07609EFD1D/train",
		// "/media/06609F07609EFD1D/test");
	}

	private static void initMap() {
		// TODO Auto-generated method stub
		List<String> list = Arrays.asList("aaa", "aad", "aam", "aas", "adc", "add", "addpd", "addps", "addsd", "addss",
				"addsubpd", "addsubps ", "aesdec", "aesdeclast", "aesenc", "aesenclast", "aesimc", "aeskeygenassist",
				"and", "andn", "andnpd", "andnps", "andps", "arpl", "bextr", "blcfill", "blci", "blcic", "blcmask",
				"blcs", "blendpd", "blendps", "blendvpd", "blendvps", "blsfill", "blsi", "blsic", "blsmsk", "blsr",
				"bound", "bsf", "bsr", "bswap", "bt", "btc", "btr", "bts", "bzhi", "call", "cbw", "cdq", "cdqe", "clc",
				"cld", "clflush", "clgi", "cli", "clts", "cmc", "cmova", "cmovae", "cmovb", "cmovbe", "cmovc", "cmove",
				"cmovg", "cmovge", "cmovl", "cmovle", "cmovna", "cmovnae", "cmovnb", "cmovnbe", "cmovnc", "cmovne",
				"cmovng", "cmovnge", "cmovnl", "cmovnle", "cmovno", "cmovnp", "cmovns", "cmovnz", "cmovo", "cmovp",
				"cmovpe", "cmovpo", "cmovs", "cmovz", "cmp", "cmppd", "cmpps", "cmpsb", "cmpsd", "cmpsq", "cmpss",
				"cmpsw", "cmpxchg", "cmpxchg16b", "cmpxchg8b", "comisd", "comiss", "cpuid", "cqo", "crc32", "cvtdq2pd",
				"cvtdq2ps", "cvtpd2dq", "cvtpd2pi", "cvtpd2ps", "cvtpi2pd", "cvtpi2ps", "cvtps2dq", "cvtps2pd",
				"cvtps2pi", "cvtsd2si", "cvtsd2ss", "cvtsi2sd", "cvtsi2ss", "cvtss2sd", "cvtss2si", "cvttpd2dq",
				"cvttpd2pi", "cvttps2dq", "cvttps2pi", "cvttsd2si", "cvttss2si", "cwd", "cwde", "daa", "das", "dec",
				"div", "divpd", "divps", "divsd", "divss", "dppd", "dpps", "emms", "enter", "esc", "extractps", "extrq",
				"f2xm1", "fabs", "fadd", "faddp", "fbld", "fbstp", "fchs", "fclex", "fcmov", "fcmovb", "fcmovbe",
				"fcmove", "fcmovnb", "fcmovnbe", "fcmovne", "fcmovnu", "fcmovu", "fcom", "fcomp", "fcompp", "fcos",
				"fdecstp", "fdisi", "fdiv", "fdivp", "fdivr", "fdivrp", "femms", "feni", "ffree", "ffreep ", "fiadd",
				"ficom", "ficomp", "fidiv", "fidivr", "fild", "fimul", "fincstp", "finit", "fist", "fistp", "fisttp ",
				"fisub", "fisubr", "fld", "fld1", "fldcw", "fldenv", "fldenvd", "fldenvw", "fldl2e", "fldl2t", "fldlg2",
				"fldln2", "fldpi", "fldz", "fmul", "fmulp", "fnclex", "fndisi", "fneni", "fninit", "fnop", "fnsave",
				"fnsavew", "fnstcw", "fnstenv", "fnstenvw", "fnstsw", "fpatan", "fprem", "fprem1", "fptan", "frndint",
				"frstor", "frstord", "frstorw", "fsave", "fsaved", "fsavew", "fscale", "fsetpm", "fsin", "fsincos",
				"fsqrt", "fst", "fstcw", "fstenv", "fstenvd", "fstenvw", "fstp", "fstsw", "fsub", "fsubp", "fsubr",
				"fsubrp", "ftst", "fucom", "fucomp", "fucompp", "fwait", "fxam", "fxch", "fxrstor", "fxsave", "fxtract",
				"fyl2x", "fyl2xp1", "haddpd", "haddps", "hlt", "hsubpd", "hsubps ", "icebp", "idiv", "imul", "in",
				"inc", "ins", "insd", "insertps", "insertq", "int", "into", "invd", "invlpg", "invlpga", "iret",
				"iretd", "iretf", "iretq", "ja", "jae", "jb", "jbe", "jc", "jcxz", "je", "jecxz", "jg", "jge", "jl",
				"jle", "jmp", "jna", "jnae", "jnb", "jnbe", "jnc", "jne", "jng", "jnge", "jnl", "jnle", "jno", "jnp",
				"jns", "jnz", "jo", "jp", "jpe", "jpo", "jrcxz", "js", "jz", "lahf", "lar", "lddqu ", "ldmxcsr", "lds",
				"lea", "leave", "les", "lfence", "lfs", "lgdt", "lgs", "lidt", "lldt", "lmsw", "loadall", "loadalld",
				"lock", "lodsb", "lodsd", "lodsq", "lodsw", "loop", "loopd", "loope", "looped", "loopew", "loopne",
				"loopned", "loopnew", "loopnz", "loopnzd", "loopnzw", "loopw", "loopz", "loopzd", "loopzw", "lsl",
				"lss", "ltr", "lzcnt", "maskmovdqu", "maskmovq", "maxpd", "maxps", "maxsd", "maxss", "mfence", "minpd",
				"minps", "minsd", "minss", "monitor", "mov", "movapd", "movaps", "movd", "movddup", "movdq2q", "movdqa",
				"movdqu", "movhlps", "movhpd", "movhps", "movlhps", "movlpd", "movlps", "movmskpd", "movmskps",
				"movntdq", "movntdqa", "movnti", "movntpd", "movntps", "movntq", "movntsd", "movntss", "movq",
				"movq2dq", "movsb", "movsd", "movshdup", "movsldup", "movss", "movsw", "movsx", "movsxd", "movupd",
				"movups", "movzx", "mpsadbw", "mul", "mulpd", "mulps", "mulsd", "mulss", "mulx", "mwait", "neg", "nop",
				"not", "or", "orpd", "orps", "out", "outs", "outsd", "pabsb", "pabsd", "pabsw", "packssdw", "packsswb",
				"packusdw", "packuswb", "paddb", "paddd", "paddq", "paddsb", "paddsiw", "paddsw", "paddusb", "paddusw",
				"paddw", "palignr", "pand", "pandn", "pause", "paveb", "pavgb", "pavgusb", "pavgw", "pblendvb",
				"pblendw", "pcmpeqb", "pcmpeqd", "pcmpeqq", "pcmpeqw", "pcmpestri", "pcmpestrm", "pcmpgtb", "pcmpgtd",
				"pcmpgtq", "pcmpgtw", "pcmpistri", "pcmpistrm", "pdep", "pdistib", "pext", "pextrb", "pextrd", "pextrq",
				"pextrw", "pf2id", "pf2iw", "pfacc", "pfadd", "pfcmpeq", "pfcmpge", "pfcmpgt", "pfmax", "pfmin",
				"pfmul", "pfnacc", "pfpnacc", "pfrcp", "pfrcpit1", "pfrcpit2", "pfrcpv", "pfrsqit1", "pfrsqrt",
				"pfrsqrtv", "pfsub", "pfsubr", "phaddd", "phaddsw", "phaddw", "phminposuw", "phsubd", "phsubsw",
				"phsubw", "pi2fd", "pi2fw", "pinsrb", "pinsrd", "pinsrq", "pinsrw", "pmachriw", "pmaddubsw", "pmaddwd",
				"pmagw", "pmaxsb", "pmaxsd", "pmaxsw", "pmaxub", "pmaxud", "pmaxuw", "pminsb", "pminsd", "pminsw",
				"pminub", "pminud", "pminuw", "pmovmskb", "pmovsxbd", "pmovsxbq", "pmovsxbw", "pmovsxdq", "pmovsxwd",
				"pmovsxwq", "pmovzxbd", "pmovzxbq", "pmovzxbw", "pmovzxdq", "pmovzxwd", "pmovzxwq", "pmuldq",
				"pmulhriw", "pmulhrsw", "pmulhrw", "pmulhuw", "pmulhw", "pmulld", "pmullw", "pmuludq", "pmvgezb",
				"pmvlzb", "pmvnzb", "pmvzb", "pop", "popa", "popad", "popcnt ", "popf", "popfd", "popfq", "por",
				"prefetch", "prefetch0", "prefetch1", "prefetch2", "prefetchnta", "prefetcht0", "prefetcht1",
				"prefetcht2", "prefetchw", "psadbw", "pshufb", "pshufd", "pshufhw", "pshuflw", "pshufw", "psignb",
				"psignd", "psignw", "pslld", "pslldq", "psllq", "psllw", "psrad", "psraw", "psrld", "psrldq", "psrlq",
				"psrlw", "psubb", "psubd", "psubq", "psubsb", "psubsiw", "psubsw", "psubusb", "psubusw", "psubw",
				"pswapd", "ptest", "punpckhbw", "punpckhdq", "punpckhqdq", "punpckhwd", "punpcklbw", "punpckldq",
				"punpcklqdq", "punpcklwd", "push", "pusha", "pushad", "pushf", "pushfd", "pushfq", "pxor", "rcl",
				"rcpps", "rcpss", "rcr", "rdmsr", "rdpmc", "rdtsc", "rdtscp", "rep", "repe", "repne", "repnz", "repz",
				"ret", "retf", "retn", "rol", "ror", "rorx", "roundpd", "roundps", "roundsd", "roundss", "rsm",
				"rsqrtps", "rsqrtss", "sahf", "sal", "salc", "sar", "sarx", "sbb", "scasb", "scasd", "scasq", "scasw",
				"seta", "setae", "setb", "setbe", "setc", "sete", "setg", "setge", "setl", "setle", "setna", "setnae",
				"setnb", "setnbe", "setnc", "setne", "setng", "setnge", "setnl", "setnle", "setno", "setnp", "setns",
				"setnz", "seto", "setp", "setpe", "setpo", "sets", "setz", "sfence", "sgdt", "shl", "shld", "shlx",
				"shr", "shrd", "shrx", "shufpd", "shufps", "sidt", "skinit", "sldt", "smsw", "sqrtpd", "sqrtps",
				"sqrtsd", "sqrtss", "stc", "std", "stgi", "sti", "stmxcsr", "stosb", "stosd", "stosq", "stosw", "str",
				"sub", "subpd", "subps", "subsd", "subss", "swapgs", "syscall", "sysenter", "sysexit", "sysret",
				"t1mskc", "test", "tzcnt", "tzmsk", "ucomisd", "ucomiss", "ud1", "ud2", "unpckhpd", "unpckhps",
				"unpcklpd", "unpcklps", "verr", "verw", "vfmaddpd", "vfmaddps", "vfmaddsd", "vfmaddss", "vfmaddsubpd",
				"vfmaddsubps", "vfmsubaddpd", "vfmsubaddps", "vfmsubpd", "vfmsubps", "vfmsubsd", "vfmsubss",
				"vfnmaddpd", "vfnmaddps", "vfnmaddsd", "vfnmaddss", "vfnmsubpd", "vfnmsubps", "vfnmsubsd", "vfnmsubss",
				"vmcall", "vmclear", "vmlaunch", "vmload", "vmmcall", "vmptrld", "vmptrst", "vmread", "vmresume",
				"vmrun", "vmsave", "vmwrite", "vmxoff", "vmxon", "wait", "wbinvd", "wrmsr", "xadd", "xchg", "xlat",
				"xor", "xorpd", "xorps");
		for (int i = 0; i < list.size(); i++) {
			instruc.put(list.get(i), true);
		}
	}

	private static void featureExtract(String trainPath, String testPath, String trainDestFile) {

		List<String> instructions = new ArrayList<String>();
		// read file recursively
		try {
			File root = new File(trainPath), root2 = new File(testPath);
			File[] list = root.listFiles(), list2 = root2.listFiles();

			BufferedReader br = null;
			String fileName = "";
			String[] s;
			String line = "";
			String[] parts;

			List<Map<String, Integer>> mapList = new ArrayList<Map<String, Integer>>();
			List<String> fileNameList = new ArrayList<String>();
			String instru = "";
			String lastInstru = "";
			String twoGram = "";
			String lastTwoGram = "";
			String threeGram = "";
			String lastThreeGram = "";
			String fourGram = "";
			String lastfourGram = "";
			String fiveGram = "";
			for (int i = 0; i < list.length; i++) {
				Map<String, Integer> map = new HashMap<String, Integer>();
				fileName = list[i].getName();
				s = fileName.split(Pattern.quote("."));
				fileName = s[0];
				fileNameList.add(fileName);
				br = new BufferedReader(new FileReader(list[i]));
				line = br.readLine();
				System.out.println(i);

				while (line != null) {
					parts = line.split("       ");

					if (parts.length >= 2) {
						for (int j = 1; j < parts.length; j++) {
							// System.out.println(instru);
							instru = parts[j].split(" ")[0];
							instru = instru.trim();

							if (instruc.containsKey(instru)) {

								// if (!instructions.contains(instru)) {
								// instructions.add(instru);
								// }
								// if (map.containsKey(instru)) {
								// map.put(instru, map.get(instru) + 1);
								// } else {
								// map.put(instru, 1);
								// }

								if (!lastInstru.equals("")) {
									// System.out.println(twoGram);
									twoGram = lastInstru + "_" + instru;

									// if (!instructions.contains(twoGram)) {
									// instructions.add(twoGram);
									// }
									// if (map.containsKey(twoGram)) {
									// map.put(twoGram, map.get(twoGram) + 1);
									// } else {
									// map.put(twoGram, 1);
									// }
								}

								if (!lastTwoGram.equals("")) {
									// System.out.println(twoGram);
									threeGram = lastTwoGram + "_" + instru;
									// if (!instructions.contains(threeGram)) {
									// instructions.add(threeGram);
									// }
									// if (map.containsKey(threeGram)) {
									// map.put(threeGram, map.get(threeGram) +
									// 1);
									// } else {
									// map.put(threeGram, 1);
									// }
								}
								if (!lastThreeGram.equals("")) {
									// System.out.println(twoGram);
									fourGram = lastThreeGram + "_" + instru;
//									if (!instructions.contains(fourGram)) {
//										instructions.add(fourGram);
//									}
//									if (map.containsKey(fourGram)) {
//										map.put(fourGram, map.get(fourGram) + 1);
//									} else {
//										map.put(fourGram, 1);
//									}
								}
								if (!lastfourGram.equals("")) {
									// System.out.println(twoGram);
									fiveGram = lastfourGram + "_" + instru;
									if (!instructions.contains(fiveGram)) {
										instructions.add(fiveGram);
									}
									if (map.containsKey(fiveGram)) {
										map.put(fiveGram, map.get(fiveGram) + 1);
									} else {
										map.put(fiveGram, 1);
									}
								}
								lastInstru = instru;
								lastTwoGram = twoGram;
								lastThreeGram = threeGram;
								lastfourGram = fourGram;
							} else {
								lastInstru = "";
								lastTwoGram = "";
								lastThreeGram = "";
								lastfourGram = "";
							}
						}

					}
					line = br.readLine();
				}
				br.close();
				mapList.add(map);

			}

			for (int i = 0; i < list2.length; i++) {
				Map<String, Integer> map = new HashMap<String, Integer>();
				fileName = list2[i].getName();
				s = fileName.split(Pattern.quote("."));
				fileName = s[0];
				fileNameList.add(fileName);
				br = new BufferedReader(new FileReader(list2[i]));
				line = br.readLine();
				System.out.println(i);

				while (line != null) {
					parts = line.split("       ");

					if (parts.length >= 2) {
						for (int j = 1; j < parts.length; j++) {
							// System.out.println(instru);
							instru = parts[j].split(" ")[0];
							instru = instru.trim();

							if (instruc.containsKey(instru)) {

								// if (!instructions.contains(instru)) {
								// instructions.add(instru);
								// }
								// if (map.containsKey(instru)) {
								// map.put(instru, map.get(instru) + 1);
								// } else {
								// map.put(instru, 1);
								// }

								if (!lastInstru.equals("")) {
									// System.out.println(twoGram);
									twoGram = lastInstru + "_" + instru;

									// if (!instructions.contains(twoGram)) {
									// instructions.add(twoGram);
									// }
									// if (map.containsKey(twoGram)) {
									// map.put(twoGram, map.get(twoGram) + 1);
									// } else {
									// map.put(twoGram, 1);
									// }
								}

								if (!lastTwoGram.equals("")) {
									// System.out.println(twoGram);
									threeGram = lastTwoGram + "_" + instru;
									// if (!instructions.contains(threeGram)) {
									// instructions.add(threeGram);
									// }
									// if (map.containsKey(threeGram)) {
									// map.put(threeGram, map.get(threeGram) +
									// 1);
									// } else {
									// map.put(threeGram, 1);
									// }
								}
								if (!lastThreeGram.equals("")) {
									// System.out.println(twoGram);
									fourGram = lastThreeGram + "_" + instru;
//									if (!instructions.contains(fourGram)) {
//										instructions.add(fourGram);
//									}
//									if (map.containsKey(fourGram)) {
//										map.put(fourGram, map.get(fourGram) + 1);
//									} else {
//										map.put(fourGram, 1);
//									}
								}
								if (!lastfourGram.equals("")) {
									// System.out.println(twoGram);
									fiveGram = lastfourGram + "_" + instru;
									if (!instructions.contains(fiveGram)) {
										instructions.add(fiveGram);
									}
									if (map.containsKey(fiveGram)) {
										map.put(fiveGram, map.get(fiveGram) + 1);
									} else {
										map.put(fiveGram, 1);
									}
								}
								lastInstru = instru;
								lastTwoGram = twoGram;
								lastThreeGram = threeGram;
								lastfourGram = fourGram;
							} else {
								lastInstru = "";
								lastTwoGram = "";
								lastThreeGram = "";
								lastfourGram = "";
							}
						}

					}
					line = br.readLine();
				}
				br.close();
				mapList.add(map);

			}

			br = new BufferedReader(new FileReader("trainlabels.txt"));
			Map<String, String> trainLabels = new HashMap<String, String>();
			line = br.readLine();
			while (line != null) {
				trainLabels.put(line.substring(1, 21), line.substring(23, 24));
				line = br.readLine();
			}
			br.close();

			BufferedWriter wr = new BufferedWriter(new FileWriter(trainDestFile));
			wr.write("@relation malware\n\n@attribute filename string\n");
			for (int j = 0; j < instructions.size(); j++) {
				wr.write("@attribute " + instructions.get(j) + " numeric\n");
			}
			wr.write("@attribute Class {1,2,3,4,5,6,7,8,9}\n\n@data\n\n");

			for (int i = 0; i < mapList.size(); i++) {
				wr.write(fileNameList.get(i));
				for (int j = 0; j < instructions.size(); j++) {
					if (mapList.get(i).containsKey(instructions.get(j))) {
						// System.out.println(map.get(instrutions.get(j)));
						wr.write("," + mapList.get(i).get(instructions.get(j)));
					} else {
						wr.write(",0");
					}
				}
				if (trainLabels.containsKey(fileNameList.get(i))) {
					wr.write("," + trainLabels.get(fileNameList.get(i)) + "\n");
				} else {
					wr.write(",?\n");
				}
			}

			wr.close();

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	static public void trimFile(String path) {
		// read file recursively
		try {
			File root = new File(path);
			File[] list = root.listFiles();

			BufferedReader br = null;
			BufferedWriter wr = null;
			String fileName = "";
			String suffix = "";
			String[] s;
			String line = "";
			for (int i = 0; i < 1; i++) {
				fileName = list[i].getName();
				s = fileName.split(Pattern.quote("."));
				fileName = s[0];
				suffix = s[1];
				System.out.println(suffix);
				if (suffix.equals("asm")) {
					br = new BufferedReader(new FileReader(list[i]));
					wr = new BufferedWriter(new FileWriter(list[i].getPath() + "code"));
					line = br.readLine();
					while (line != null) {
						if (line.startsWith(".data:") || line.startsWith(".rdata:")) {
						} else {
							// System.out.println(line);
							wr.write(line + "\n");
						}
						line = br.readLine();
					}
					br.close();
					wr.close();
					list[i].delete();
				} else if (suffix.equals("bytes")) {
					list[i].delete();
				}
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	static public void instru() {

		String line;
		try {
			BufferedReader br = new BufferedReader(new FileReader("instru.txt"));
			line = br.readLine();
			while (line != null) {
				System.out.print("\"" + line.toLowerCase() + "\", ");
				line = br.readLine();
			}
			System.out.println();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
